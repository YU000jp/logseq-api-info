{
  "interfaces": [
    {
      "name": "AppGraphInfo",
      "body": "name: string\n  url: string\n  path: string\n\n  [key: string]: unknown",
      "fullDefinition": "export interface AppGraphInfo {\n  name: string\n  url: string\n  path: string\n\n  [key: string]: unknown\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "AppInfo",
      "body": "version: string\n  supportDb: boolean\n\n  [key: string]: unknown",
      "fullDefinition": "export interface AppInfo {\n  version: string\n  supportDb: boolean\n\n  [key: string]: unknown\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "AppUserConfigs",
      "body": "preferredThemeMode: ThemeMode\n  preferredFormat: 'markdown' | 'org'\n  preferredDateFormat: string\n  preferredStartOfWeek: string\n  preferredLanguage: string\n  preferredWorkflow: string\n\n  currentGraph: string\n  showBracket: boolean\n  enabledFlashcards: boolean\n  enabledJournals: boolean\n\n  [key: string]: unknown",
      "fullDefinition": "export interface AppUserConfigs {\n  preferredThemeMode: ThemeMode\n  preferredFormat: 'markdown' | 'org'\n  preferredDateFormat: string\n  preferredStartOfWeek: string\n  preferredLanguage: string\n  preferredWorkflow: string\n\n  currentGraph: string\n  showBracket: boolean\n  enabledFlashcards: boolean\n  enabledJournals: boolean\n\n  [key: string]: unknown\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "AppUserInfo",
      "body": "[key: string]: any",
      "fullDefinition": "export interface AppUserInfo {\n  [key: string]: any\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "BlockEntity",
      "body": "id: EntityID // db id\n  uuid: BlockUUID\n  order: string\n  format: 'markdown' | 'org'\n  parent: IEntityID\n  title: string\n  content?: string // @deprecated. Use :title instead!\n  page: IEntityID // owner page\n  createdAt: number\n  updatedAt: number\n  ident?: string // ident for property block\n  properties?: Record<string, any>\n  'collapsed?': boolean\n\n  // optional fields in dummy page\n  anchor?: string\n  body?: any\n  children?: Array<BlockEntity | BlockUUIDTuple>\n  container?: string\n  file?: IEntityID\n  level?: number\n  meta?: { timestamps: any; properties: any; startPos: number; endPos: number",
      "fullDefinition": "export interface BlockEntity {\n  id: EntityID // db id\n  uuid: BlockUUID\n  order: string\n  format: 'markdown' | 'org'\n  parent: IEntityID\n  title: string\n  content?: string // @deprecated. Use :title instead!\n  page: IEntityID // owner page\n  createdAt: number\n  updatedAt: number\n  ident?: string // ident for property block\n  properties?: Record<string, any>\n  'collapsed?': boolean\n\n  // optional fields in dummy page\n  anchor?: string\n  body?: any\n  children?: Array<BlockEntity | BlockUUIDTuple>\n  container?: string\n  file?: IEntityID\n  level?: number\n  meta?: { timestamps: any; properties: any; startPos: number; endPos: number }",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IAppProxy",
      "body": "/**\n   * @added 0.0.4\n   * @param key\n   */\n  getInfo: (key?: keyof AppInfo) => Promise<AppInfo | any>\n\n  getUserInfo: () => Promise<AppUserInfo | null>\n  getUserConfigs: () => Promise<AppUserConfigs>\n\n  // services\n  registerSearchService<T extends IPluginSearchServiceHooks>(s: T): void\n\n  // commands\n  registerCommand: (\n    type: string,\n    opts: {\n      key: string\n      label: string\n      desc?: string\n      palette?: boolean\n      keybinding?: SimpleCommandKeybinding",
      "fullDefinition": "export interface IAppProxy {\n  /**\n   * @added 0.0.4\n   * @param key\n   */\n  getInfo: (key?: keyof AppInfo) => Promise<AppInfo | any>\n\n  getUserInfo: () => Promise<AppUserInfo | null>\n  getUserConfigs: () => Promise<AppUserConfigs>\n\n  // services\n  registerSearchService<T extends IPluginSearchServiceHooks>(s: T): void\n\n  // commands\n  registerCommand: (\n    type: string,\n    opts: {\n      key: string\n      label: string\n      desc?: string\n      palette?: boolean\n      keybinding?: SimpleCommandKeybinding\n    }",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IAssetsProxy",
      "body": "/**\n   * @added 0.0.2\n   * @param exts\n   */\n  listFilesOfCurrentGraph(exts?: string | string[]): Promise<\n    Array<{\n      path: string\n      size: number\n      accessTime: number\n      modifiedTime: number\n      changeTime: number\n      birthTime: number",
      "fullDefinition": "export interface IAssetsProxy {\n  /**\n   * @added 0.0.2\n   * @param exts\n   */\n  listFilesOfCurrentGraph(exts?: string | string[]): Promise<\n    Array<{\n      path: string\n      size: number\n      accessTime: number\n      modifiedTime: number\n      changeTime: number\n      birthTime: number\n    }",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IAsyncStorage",
      "body": "getItem(key: string): Promise<string | undefined>\n\n  setItem(key: string, value: string): Promise<void>\n\n  removeItem(key: string): Promise<void>\n\n  hasItem(key: string): Promise<boolean>\n\n  allKeys(): Promise<Array<string>>\n\n  clear(): Promise<void>",
      "fullDefinition": "export interface IAsyncStorage {\n  getItem(key: string): Promise<string | undefined>\n\n  setItem(key: string, value: string): Promise<void>\n\n  removeItem(key: string): Promise<void>\n\n  hasItem(key: string): Promise<boolean>\n\n  allKeys(): Promise<Array<string>>\n\n  clear(): Promise<void>\n}",
      "file": "modules/LSPlugin.Storage.ts"
    },
    {
      "name": "IDBProxy",
      "body": "/**\n   * Run a DSL query\n   * @link https://docs.logseq.com/#/page/queries\n   * @param dsl\n   */\n  q: <T = any>(dsl: string) => Promise<Array<T> | null>\n\n  /**\n   * Run a datascript query\n   */\n  datascriptQuery: <T = any>(query: string, ...inputs: Array<any>) => Promise<T>\n\n  /**\n   * Hook all transaction data of DB\n   *\n   * @added 0.0.2\n   */\n  onChanged: IUserHook<{\n    blocks: Array<BlockEntity>\n    txData: Array<IDatom>\n    txMeta?: { outlinerOp: string; [key: string]: any",
      "fullDefinition": "export interface IDBProxy {\n  /**\n   * Run a DSL query\n   * @link https://docs.logseq.com/#/page/queries\n   * @param dsl\n   */\n  q: <T = any>(dsl: string) => Promise<Array<T> | null>\n\n  /**\n   * Run a datascript query\n   */\n  datascriptQuery: <T = any>(query: string, ...inputs: Array<any>) => Promise<T>\n\n  /**\n   * Hook all transaction data of DB\n   *\n   * @added 0.0.2\n   */\n  onChanged: IUserHook<{\n    blocks: Array<BlockEntity>\n    txData: Array<IDatom>\n    txMeta?: { outlinerOp: string; [key: string]: any }",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IEditorProxy",
      "body": "/**\n   * register a custom command which will be added to the Logseq slash command list\n   * @param tag - displayed name of command\n   * @param action - can be a single callback function to run when the command is called, or an array of fixed commands with arguments\n   *\n   *\n   * @example https://github.com/logseq/logseq-plugin-samples/tree/master/logseq-slash-commands\n   *\n   * @example\n   * ```ts\n   * logseq.Editor.registerSlashCommand(\"Say Hi\", () => {\n   *   console.log('Hi!')\n   *",
      "fullDefinition": "export interface IEditorProxy extends Record<string, any> {\n  /**\n   * register a custom command which will be added to the Logseq slash command list\n   * @param tag - displayed name of command\n   * @param action - can be a single callback function to run when the command is called, or an array of fixed commands with arguments\n   *\n   *\n   * @example https://github.com/logseq/logseq-plugin-samples/tree/master/logseq-slash-commands\n   *\n   * @example\n   * ```ts\n   * logseq.Editor.registerSlashCommand(\"Say Hi\", () => {\n   *   console.log('Hi!')\n   * }",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IGitProxy",
      "body": "/**\n   * @added 0.0.2\n   * @link https://github.com/desktop/dugite/blob/master/docs/api/exec.md\n   * @param args\n   */\n  execCommand: (args: string[]) => Promise<IGitResult>\n\n  loadIgnoreFile: () => Promise<string>\n  saveIgnoreFile: (content: string) => Promise<void>",
      "fullDefinition": "export interface IGitProxy {\n  /**\n   * @added 0.0.2\n   * @link https://github.com/desktop/dugite/blob/master/docs/api/exec.md\n   * @param args\n   */\n  execCommand: (args: string[]) => Promise<IGitResult>\n\n  loadIgnoreFile: () => Promise<string>\n  saveIgnoreFile: (content: string) => Promise<void>\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "ILSPluginThemeManager",
      "body": "get themes(): Map<PluginLocalIdentity, Theme[]>\n\n  registerTheme(id: PluginLocalIdentity, opt: Theme): Promise<void>\n\n  unregisterTheme(id: PluginLocalIdentity, effect?: boolean): Promise<void>\n\n  selectTheme(\n    opt: Theme | LegacyTheme,\n    options: { effect?: boolean; emit?: boolean",
      "fullDefinition": "export interface ILSPluginThemeManager {\n  get themes(): Map<PluginLocalIdentity, Theme[]>\n\n  registerTheme(id: PluginLocalIdentity, opt: Theme): Promise<void>\n\n  unregisterTheme(id: PluginLocalIdentity, effect?: boolean): Promise<void>\n\n  selectTheme(\n    opt: Theme | LegacyTheme,\n    options: { effect?: boolean; emit?: boolean }",
      "file": "LSPlugin.ts"
    },
    {
      "name": "ILSPluginUser",
      "body": "/**\n   * Connection status with the main app\n   */\n  connected: boolean\n\n  /**\n   * Duplex message caller\n   */\n  caller: LSPluginCaller\n\n  /**\n   * The plugin configurations from package.json\n   */\n  baseInfo: LSPluginBaseInfo\n\n  /**\n   * The plugin user settings\n   */\n  settings?: LSPluginBaseInfo['settings']\n\n  /**\n   * The main Logseq app is ready to run the plugin\n   *\n   * @param model - same as the model in `provideModel`\n   */\n  ready(model?: Record<string, any>): Promise<any>\n\n  /**\n   * @param callback - a function to run when the main Logseq app is ready\n   */\n  ready(callback?: (e: any) => void | {",
      "fullDefinition": "export interface ILSPluginUser extends EventEmitter<LSPluginUserEvents> {\n  /**\n   * Connection status with the main app\n   */\n  connected: boolean\n\n  /**\n   * Duplex message caller\n   */\n  caller: LSPluginCaller\n\n  /**\n   * The plugin configurations from package.json\n   */\n  baseInfo: LSPluginBaseInfo\n\n  /**\n   * The plugin user settings\n   */\n  settings?: LSPluginBaseInfo['settings']\n\n  /**\n   * The main Logseq app is ready to run the plugin\n   *\n   * @param model - same as the model in `provideModel`\n   */\n  ready(model?: Record<string, any>): Promise<any>\n\n  /**\n   * @param callback - a function to run when the main Logseq app is ready\n   */\n  ready(callback?: (e: any) => void | {}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IPluginSearchServiceHooks",
      "body": "name: string\n  options?: Record<string, any>\n\n  onQuery: (\n    graph: string,\n    key: string,\n    opts: Partial<{ limit: number",
      "fullDefinition": "export interface IPluginSearchServiceHooks {\n  name: string\n  options?: Record<string, any>\n\n  onQuery: (\n    graph: string,\n    key: string,\n    opts: Partial<{ limit: number }",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IUIProxy",
      "body": "showMsg: (\n    content: string,\n    status?: 'success' | 'warning' | 'error' | string,\n    opts?: Partial<UIMsgOptions>\n  ) => Promise<UIMsgKey>\n  closeMsg: (key: UIMsgKey) => void\n  queryElementRect: (selector: string) => Promise<DOMRectReadOnly | null>\n  queryElementById: (id: string) => Promise<string | boolean>\n  checkSlotValid: (slot: UISlotIdentity['slot']) => Promise<boolean>\n  resolveThemeCssPropsVals: (props: string | Array<string>) => Promise<Record<string, string | undefined> | null>",
      "fullDefinition": "export interface IUIProxy {\n  showMsg: (\n    content: string,\n    status?: 'success' | 'warning' | 'error' | string,\n    opts?: Partial<UIMsgOptions>\n  ) => Promise<UIMsgKey>\n  closeMsg: (key: UIMsgKey) => void\n  queryElementRect: (selector: string) => Promise<DOMRectReadOnly | null>\n  queryElementById: (id: string) => Promise<string | boolean>\n  checkSlotValid: (slot: UISlotIdentity['slot']) => Promise<boolean>\n  resolveThemeCssPropsVals: (props: string | Array<string>) => Promise<Record<string, string | undefined> | null>\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IUtilsProxy",
      "body": "toJs: <R = unknown>(obj: {",
      "fullDefinition": "export interface IUtilsProxy {\n  toJs: <R = unknown>(obj: {}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "LegacyTheme",
      "body": "name: string\n  url: string\n  description?: string\n  mode?: ThemeMode\n  pid: PluginLocalIdentity",
      "fullDefinition": "export interface LegacyTheme {\n  name: string\n  url: string\n  description?: string\n  mode?: ThemeMode\n  pid: PluginLocalIdentity\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "LSPluginBaseInfo",
      "body": "/**\n   * Must be unique.\n   */\n  id: string\n  mode: 'shadow' | 'iframe'\n  settings: {\n    disabled: boolean",
      "fullDefinition": "export interface LSPluginBaseInfo {\n  /**\n   * Must be unique.\n   */\n  id: string\n  mode: 'shadow' | 'iframe'\n  settings: {\n    disabled: boolean\n  }",
      "file": "LSPlugin.ts"
    },
    {
      "name": "LSPluginPkgConfig",
      "body": "id: PluginLocalIdentity\n  main: string\n  entry: string // alias of main\n  title: string\n  mode: 'shadow' | 'iframe'\n  themes: Theme[]\n  icon: string\n  /**\n   * Alternative entrypoint for development.\n   */\n  devEntry: unknown\n  /**\n   * For legacy themes, do not use.\n   */\n  theme: unknown",
      "fullDefinition": "export interface LSPluginPkgConfig {\n  id: PluginLocalIdentity\n  main: string\n  entry: string // alias of main\n  title: string\n  mode: 'shadow' | 'iframe'\n  themes: Theme[]\n  icon: string\n  /**\n   * Alternative entrypoint for development.\n   */\n  devEntry: unknown\n  /**\n   * For legacy themes, do not use.\n   */\n  theme: unknown\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "PageEntity",
      "body": "id: EntityID\n  uuid: BlockUUID\n  name: string\n  format: 'markdown' | 'org'\n  type: 'page' | 'journal' | 'whiteboard' | 'class' | 'property' | 'hidden'\n  updatedAt: number\n  createdAt: number\n  'journal?': boolean\n\n  title?: string\n  file?: IEntityID\n  originalName?: string\n  namespace?: IEntityID\n  children?: Array<PageEntity>\n  properties?: Record<string, any>\n  journalDay?: number\n\n  [key: string]: unknown",
      "fullDefinition": "export interface PageEntity {\n  id: EntityID\n  uuid: BlockUUID\n  name: string\n  format: 'markdown' | 'org'\n  type: 'page' | 'journal' | 'whiteboard' | 'class' | 'property' | 'hidden'\n  updatedAt: number\n  createdAt: number\n  'journal?': boolean\n\n  title?: string\n  file?: IEntityID\n  originalName?: string\n  namespace?: IEntityID\n  children?: Array<PageEntity>\n  properties?: Record<string, any>\n  journalDay?: number\n\n  [key: string]: unknown\n}",
      "file": "LSPlugin.ts"
    },
    {
      "name": "Theme",
      "body": "mode: ThemeMode",
      "fullDefinition": "export interface Theme extends LegacyTheme {\n  mode: ThemeMode\n}",
      "file": "LSPlugin.ts"
    }
  ],
  "types": [
    {
      "name": "BlockIdentity",
      "definition": "BlockUUID | Pick<BlockEntity, 'uuid'>\nexport type BlockPageName = string\nexport type PageIdentity = BlockPageName | BlockIdentity\nexport type SlashCommandActionCmd =\n  | 'editor/input'\n  | 'editor/hook'\n  | 'editor/clear-current-slash'\n  | 'editor/restore-saved-cursor'\nexport type SlashCommandAction = [cmd: SlashCommandActionCmd, ...args: any]\nexport type SimpleCommandCallback<E = any> = (e: IHookEvent & E) => void\nexport type BlockCommandCallback = (\n  e: IHookEvent & { uuid: BlockUUID }\n) => Promise<void>\nexport type BlockCursorPosition = {\n  left: number\n  top: number\n  height: number\n  pos: number\n  rect: DOMRect\n}\n\nexport type Keybinding = string | Array<string>\nexport type SimpleCommandKeybinding = {\n  mode?: 'global' | 'non-editing' | 'editing'\n  binding: Keybinding\n  mac?: string // special for Mac OS\n}\n\nexport type SettingSchemaDesc = {\n  key: string\n  type: 'string' | 'number' | 'boolean' | 'enum' | 'object' | 'heading'\n  default: string | number | boolean | Array<any> | object | null\n  title: string\n  description: string // support markdown\n  inputAs?: 'color' | 'date' | 'datetime-local' | 'range' | 'textarea'\n  enumChoices?: Array<string>\n  enumPicker?: 'select' | 'radio' | 'checkbox' // default: select\n}\n\nexport type ExternalCommandType =\n  | 'logseq.command/run'\n  | 'logseq.editor/cycle-todo'\n  | 'logseq.editor/down'\n  | 'logseq.editor/up'\n  | 'logseq.editor/expand-block-children'\n  | 'logseq.editor/collapse-block-children'\n  | 'logseq.editor/open-file-in-default-app'\n  | 'logseq.editor/open-file-in-directory'\n  | 'logseq.editor/select-all-blocks'\n  | 'logseq.editor/toggle-open-blocks'\n  | 'logseq.editor/zoom-in'\n  | 'logseq.editor/zoom-out'\n  | 'logseq.editor/indent'\n  | 'logseq.editor/outdent'\n  | 'logseq.editor/copy'\n  | 'logseq.editor/cut'\n  | 'logseq.go/home'\n  | 'logseq.go/journals'\n  | 'logseq.go/keyboard-shortcuts'\n  | 'logseq.go/next-journal'\n  | 'logseq.go/prev-journal'\n  | 'logseq.go/search'\n  | 'logseq.go/tomorrow'\n  | 'logseq.go/backward'\n  | 'logseq.go/forward'\n  | 'logseq.search/re-index'\n  | 'logseq.sidebar/clear'\n  | 'logseq.sidebar/open-today-page'\n  | 'logseq.ui/goto-plugins'\n  | 'logseq.ui/select-theme-color'\n  | 'logseq.ui/toggle-brackets'\n  | 'logseq.ui/toggle-contents'\n  | 'logseq.ui/toggle-document-mode'\n  | 'logseq.ui/toggle-help'\n  | 'logseq.ui/toggle-left-sidebar'\n  | 'logseq.ui/toggle-right-sidebar'\n  | 'logseq.ui/toggle-settings'\n  | 'logseq.ui/toggle-theme'\n  | 'logseq.ui/toggle-wide-mode'\n\nexport type UserProxyNSTags = 'app' | 'editor' | 'db' | 'git' | 'ui' | 'assets' | 'utils'\n\nexport type SearchIndiceInitStatus = boolean\nexport type SearchBlockItem = {\n  id: EntityID\n  uuid: BlockIdentity\n  content: string\n  page: EntityID\n}\nexport type SearchPageItem = string\nexport type SearchFileItem = string\n\nexport interface IPluginSearchServiceHooks {\n  name: string\n  options?: Record<string, any>\n\n  onQuery: (\n    graph: string,\n    key: string,\n    opts: Partial<{ limit: number }>\n  ) => Promise<{\n    graph: string\n    key: string\n    blocks?: Array<Partial<SearchBlockItem>>\n    pages?: Array<SearchPageItem>\n    files?: Array<SearchFileItem>\n  }>\n\n  onIndiceInit: (graph: string) => Promise<SearchIndiceInitStatus>\n  onIndiceReset: (graph: string) => Promise<void>\n  onBlocksChanged: (\n    graph: string,\n    changes: {\n      added: Array<SearchBlockItem>\n      removed: Array<EntityID>\n    }\n  ) => Promise<void>\n  onGraphRemoved: (graph: string, opts?: {}) => Promise<any>\n}\n\n/**\n * App level APIs\n */\nexport interface IAppProxy {\n  /**\n   * @added 0.0.4\n   * @param key\n   */\n  getInfo: (key?: keyof AppInfo) => Promise<AppInfo | any>\n\n  getUserInfo: () => Promise<AppUserInfo | null>\n  getUserConfigs: () => Promise<AppUserConfigs>\n\n  // services\n  registerSearchService<T extends IPluginSearchServiceHooks>(s: T): void\n\n  // commands\n  registerCommand: (\n    type: string,\n    opts: {\n      key: string\n      label: string\n      desc?: string\n      palette?: boolean\n      keybinding?: SimpleCommandKeybinding\n    },\n    action: SimpleCommandCallback\n  ) => void\n\n  registerCommandPalette: (\n    opts: {\n      key: string\n      label: string\n      keybinding?: SimpleCommandKeybinding\n    },\n    action: SimpleCommandCallback\n  ) => void\n\n  /**\n   * Supported key names\n   * @link https://gist.github.com/xyhp915/d1a6d151a99f31647a95e59cdfbf4ddc\n   * @param keybinding\n   * @param action\n   */\n  registerCommandShortcut: (\n    keybinding: SimpleCommandKeybinding | string,\n    action: SimpleCommandCallback,\n    opts?: Partial<{\n      key: string\n      label: string\n      desc: string\n      extras: Record<string, any>\n    }>\n  ) => void\n\n  /**\n   * Supported all registered palette commands\n   * @param type\n   * @param args\n   */\n  invokeExternalCommand: (\n    type: ExternalCommandType,\n    ...args: Array<any>\n  ) => Promise<void>\n\n  /**\n   * Call external plugin command provided by models or registered commands\n   * @added 0.0.13\n   * @param type `xx-plugin-id.commands.xx-key`, `xx-plugin-id.models.xx-key`\n   * @param args\n   */\n  invokeExternalPlugin: (type: string, ...args: Array<any>) => Promise<unknown>\n\n  /**\n   * @added 0.0.13\n   * @param pid\n   */\n  getExternalPlugin: (pid: string) => Promise<{} | null>\n\n  /**\n   * Get state from app store\n   * valid state is here\n   * https://github.com/logseq/logseq/blob/master/src/main/frontend/state.cljs#L27\n   *\n   * @example\n   * ```ts\n   * const isDocMode = await logseq.App.getStateFromStore('document/mode?')\n   * ```\n   * @param path\n   */\n  getStateFromStore: <T = any>(path: string | Array<string>) => Promise<T>\n  setStateFromStore: (path: string | Array<string>, value: any) => Promise<void>\n\n  // native\n  relaunch: () => Promise<void>\n  quit: () => Promise<void>\n  openExternalLink: (url: string) => Promise<void>\n\n  /**\n   * @deprecated Using `logseq.Git.execCommand`\n   * @link https://github.com/desktop/dugite/blob/master/docs/api/exec.md\n   * @param args\n   */\n  execGitCommand: (args: string[]) => Promise<string>\n\n  // graph\n  getCurrentGraph: () => Promise<AppGraphInfo | null>\n  checkCurrentIsDbGraph: () => Promise<Boolean>\n  getCurrentGraphConfigs: (...keys: string[]) => Promise<any>\n  setCurrentGraphConfigs: (configs: {}) => Promise<void>\n  getCurrentGraphFavorites: () => Promise<Array<string | PageEntity> | null>\n  getCurrentGraphRecent: () => Promise<Array<string | PageEntity> | null>\n  getCurrentGraphTemplates: () => Promise<Record<string, BlockEntity> | null>\n\n  // router\n  pushState: (\n    k: string,\n    params?: Record<string, any>,\n    query?: Record<string, any>\n  ) => void\n  replaceState: (\n    k: string,\n    params?: Record<string, any>,\n    query?: Record<string, any>\n  ) => void\n\n  // templates\n  getTemplate: (name: string) => Promise<BlockEntity | null>\n  existTemplate: (name: string) => Promise<Boolean>\n  createTemplate: (\n    target: BlockUUID,\n    name: string,\n    opts?: { overwrite: boolean }\n  ) => Promise<any>\n  removeTemplate: (name: string) => Promise<any>\n  insertTemplate: (target: BlockUUID, name: string) => Promise<any>\n\n  setZoomFactor: (factor: number) => void\n  setFullScreen: (flag: boolean | 'toggle') => void\n  setLeftSidebarVisible: (flag: boolean | 'toggle') => void\n  setRightSidebarVisible: (flag: boolean | 'toggle') => void\n  clearRightSidebarBlocks: (opts?: { close: boolean }) => void\n\n  registerUIItem: (\n    type: 'toolbar' | 'pagebar',\n    opts: { key: string",
      "fullDefinition": "export type BlockIdentity = BlockUUID | Pick<BlockEntity, 'uuid'>\nexport type BlockPageName = string\nexport type PageIdentity = BlockPageName | BlockIdentity\nexport type SlashCommandActionCmd =\n  | 'editor/input'\n  | 'editor/hook'\n  | 'editor/clear-current-slash'\n  | 'editor/restore-saved-cursor'\nexport type SlashCommandAction = [cmd: SlashCommandActionCmd, ...args: any]\nexport type SimpleCommandCallback<E = any> = (e: IHookEvent & E) => void\nexport type BlockCommandCallback = (\n  e: IHookEvent & { uuid: BlockUUID }\n) => Promise<void>\nexport type BlockCursorPosition = {\n  left: number\n  top: number\n  height: number\n  pos: number\n  rect: DOMRect\n}\n\nexport type Keybinding = string | Array<string>\nexport type SimpleCommandKeybinding = {\n  mode?: 'global' | 'non-editing' | 'editing'\n  binding: Keybinding\n  mac?: string // special for Mac OS\n}\n\nexport type SettingSchemaDesc = {\n  key: string\n  type: 'string' | 'number' | 'boolean' | 'enum' | 'object' | 'heading'\n  default: string | number | boolean | Array<any> | object | null\n  title: string\n  description: string // support markdown\n  inputAs?: 'color' | 'date' | 'datetime-local' | 'range' | 'textarea'\n  enumChoices?: Array<string>\n  enumPicker?: 'select' | 'radio' | 'checkbox' // default: select\n}\n\nexport type ExternalCommandType =\n  | 'logseq.command/run'\n  | 'logseq.editor/cycle-todo'\n  | 'logseq.editor/down'\n  | 'logseq.editor/up'\n  | 'logseq.editor/expand-block-children'\n  | 'logseq.editor/collapse-block-children'\n  | 'logseq.editor/open-file-in-default-app'\n  | 'logseq.editor/open-file-in-directory'\n  | 'logseq.editor/select-all-blocks'\n  | 'logseq.editor/toggle-open-blocks'\n  | 'logseq.editor/zoom-in'\n  | 'logseq.editor/zoom-out'\n  | 'logseq.editor/indent'\n  | 'logseq.editor/outdent'\n  | 'logseq.editor/copy'\n  | 'logseq.editor/cut'\n  | 'logseq.go/home'\n  | 'logseq.go/journals'\n  | 'logseq.go/keyboard-shortcuts'\n  | 'logseq.go/next-journal'\n  | 'logseq.go/prev-journal'\n  | 'logseq.go/search'\n  | 'logseq.go/tomorrow'\n  | 'logseq.go/backward'\n  | 'logseq.go/forward'\n  | 'logseq.search/re-index'\n  | 'logseq.sidebar/clear'\n  | 'logseq.sidebar/open-today-page'\n  | 'logseq.ui/goto-plugins'\n  | 'logseq.ui/select-theme-color'\n  | 'logseq.ui/toggle-brackets'\n  | 'logseq.ui/toggle-contents'\n  | 'logseq.ui/toggle-document-mode'\n  | 'logseq.ui/toggle-help'\n  | 'logseq.ui/toggle-left-sidebar'\n  | 'logseq.ui/toggle-right-sidebar'\n  | 'logseq.ui/toggle-settings'\n  | 'logseq.ui/toggle-theme'\n  | 'logseq.ui/toggle-wide-mode'\n\nexport type UserProxyNSTags = 'app' | 'editor' | 'db' | 'git' | 'ui' | 'assets' | 'utils'\n\nexport type SearchIndiceInitStatus = boolean\nexport type SearchBlockItem = {\n  id: EntityID\n  uuid: BlockIdentity\n  content: string\n  page: EntityID\n}\nexport type SearchPageItem = string\nexport type SearchFileItem = string\n\nexport interface IPluginSearchServiceHooks {\n  name: string\n  options?: Record<string, any>\n\n  onQuery: (\n    graph: string,\n    key: string,\n    opts: Partial<{ limit: number }>\n  ) => Promise<{\n    graph: string\n    key: string\n    blocks?: Array<Partial<SearchBlockItem>>\n    pages?: Array<SearchPageItem>\n    files?: Array<SearchFileItem>\n  }>\n\n  onIndiceInit: (graph: string) => Promise<SearchIndiceInitStatus>\n  onIndiceReset: (graph: string) => Promise<void>\n  onBlocksChanged: (\n    graph: string,\n    changes: {\n      added: Array<SearchBlockItem>\n      removed: Array<EntityID>\n    }\n  ) => Promise<void>\n  onGraphRemoved: (graph: string, opts?: {}) => Promise<any>\n}\n\n/**\n * App level APIs\n */\nexport interface IAppProxy {\n  /**\n   * @added 0.0.4\n   * @param key\n   */\n  getInfo: (key?: keyof AppInfo) => Promise<AppInfo | any>\n\n  getUserInfo: () => Promise<AppUserInfo | null>\n  getUserConfigs: () => Promise<AppUserConfigs>\n\n  // services\n  registerSearchService<T extends IPluginSearchServiceHooks>(s: T): void\n\n  // commands\n  registerCommand: (\n    type: string,\n    opts: {\n      key: string\n      label: string\n      desc?: string\n      palette?: boolean\n      keybinding?: SimpleCommandKeybinding\n    },\n    action: SimpleCommandCallback\n  ) => void\n\n  registerCommandPalette: (\n    opts: {\n      key: string\n      label: string\n      keybinding?: SimpleCommandKeybinding\n    },\n    action: SimpleCommandCallback\n  ) => void\n\n  /**\n   * Supported key names\n   * @link https://gist.github.com/xyhp915/d1a6d151a99f31647a95e59cdfbf4ddc\n   * @param keybinding\n   * @param action\n   */\n  registerCommandShortcut: (\n    keybinding: SimpleCommandKeybinding | string,\n    action: SimpleCommandCallback,\n    opts?: Partial<{\n      key: string\n      label: string\n      desc: string\n      extras: Record<string, any>\n    }>\n  ) => void\n\n  /**\n   * Supported all registered palette commands\n   * @param type\n   * @param args\n   */\n  invokeExternalCommand: (\n    type: ExternalCommandType,\n    ...args: Array<any>\n  ) => Promise<void>\n\n  /**\n   * Call external plugin command provided by models or registered commands\n   * @added 0.0.13\n   * @param type `xx-plugin-id.commands.xx-key`, `xx-plugin-id.models.xx-key`\n   * @param args\n   */\n  invokeExternalPlugin: (type: string, ...args: Array<any>) => Promise<unknown>\n\n  /**\n   * @added 0.0.13\n   * @param pid\n   */\n  getExternalPlugin: (pid: string) => Promise<{} | null>\n\n  /**\n   * Get state from app store\n   * valid state is here\n   * https://github.com/logseq/logseq/blob/master/src/main/frontend/state.cljs#L27\n   *\n   * @example\n   * ```ts\n   * const isDocMode = await logseq.App.getStateFromStore('document/mode?')\n   * ```\n   * @param path\n   */\n  getStateFromStore: <T = any>(path: string | Array<string>) => Promise<T>\n  setStateFromStore: (path: string | Array<string>, value: any) => Promise<void>\n\n  // native\n  relaunch: () => Promise<void>\n  quit: () => Promise<void>\n  openExternalLink: (url: string) => Promise<void>\n\n  /**\n   * @deprecated Using `logseq.Git.execCommand`\n   * @link https://github.com/desktop/dugite/blob/master/docs/api/exec.md\n   * @param args\n   */\n  execGitCommand: (args: string[]) => Promise<string>\n\n  // graph\n  getCurrentGraph: () => Promise<AppGraphInfo | null>\n  checkCurrentIsDbGraph: () => Promise<Boolean>\n  getCurrentGraphConfigs: (...keys: string[]) => Promise<any>\n  setCurrentGraphConfigs: (configs: {}) => Promise<void>\n  getCurrentGraphFavorites: () => Promise<Array<string | PageEntity> | null>\n  getCurrentGraphRecent: () => Promise<Array<string | PageEntity> | null>\n  getCurrentGraphTemplates: () => Promise<Record<string, BlockEntity> | null>\n\n  // router\n  pushState: (\n    k: string,\n    params?: Record<string, any>,\n    query?: Record<string, any>\n  ) => void\n  replaceState: (\n    k: string,\n    params?: Record<string, any>,\n    query?: Record<string, any>\n  ) => void\n\n  // templates\n  getTemplate: (name: string) => Promise<BlockEntity | null>\n  existTemplate: (name: string) => Promise<Boolean>\n  createTemplate: (\n    target: BlockUUID,\n    name: string,\n    opts?: { overwrite: boolean }\n  ) => Promise<any>\n  removeTemplate: (name: string) => Promise<any>\n  insertTemplate: (target: BlockUUID, name: string) => Promise<any>\n\n  setZoomFactor: (factor: number) => void\n  setFullScreen: (flag: boolean | 'toggle') => void\n  setLeftSidebarVisible: (flag: boolean | 'toggle') => void\n  setRightSidebarVisible: (flag: boolean | 'toggle') => void\n  clearRightSidebarBlocks: (opts?: { close: boolean }) => void\n\n  registerUIItem: (\n    type: 'toolbar' | 'pagebar',\n    opts: { key: string;",
      "file": "LSPlugin.ts"
    },
    {
      "name": "IBatchBlock",
      "definition": "{\n  content: string\n\n  /**\n   * @NOTE: not supported for DB graph\n   */\n  properties?: Record<string, any>\n\n  children?: Array<IBatchBlock>\n}\nexport type IDatom = [e: number, a: string, v: any, t: number, added: boolean]\n\nexport type IGitResult = { stdout: string",
      "fullDefinition": "export type IBatchBlock = {\n  content: string\n\n  /**\n   * @NOTE: not supported for DB graph\n   */\n  properties?: Record<string, any>\n\n  children?: Array<IBatchBlock>\n}\nexport type IDatom = [e: number, a: string, v: any, t: number, added: boolean]\n\nexport type IGitResult = { stdout: string;",
      "file": "LSPlugin.ts"
    },
    {
      "name": "LSPluginUserEvents",
      "definition": "'ui:visible:changed' | 'settings:changed'\n\nexport interface ILSPluginUser extends EventEmitter<LSPluginUserEvents> {\n  /**\n   * Connection status with the main app\n   */\n  connected: boolean\n\n  /**\n   * Duplex message caller\n   */\n  caller: LSPluginCaller\n\n  /**\n   * The plugin configurations from package.json\n   */\n  baseInfo: LSPluginBaseInfo\n\n  /**\n   * The plugin user settings\n   */\n  settings?: LSPluginBaseInfo['settings']\n\n  /**\n   * The main Logseq app is ready to run the plugin\n   *\n   * @param model - same as the model in `provideModel`\n   */\n  ready(model?: Record<string, any>): Promise<any>\n\n  /**\n   * @param callback - a function to run when the main Logseq app is ready\n   */\n  ready(callback?: (e: any) => void | {}): Promise<any>\n\n  ready(\n    model?: Record<string, any>,\n    callback?: (e: any) => void | {}\n  ): Promise<any>\n\n  beforeunload: (callback: () => Promise<void>) => void\n\n  /**\n   * Create a object to hold the methods referenced in `provideUI`\n   *\n   * @example\n   * ```ts\n   * logseq.provideModel({\n   *  openCalendar () {\n   *    console.log('Open the calendar!')\n   *  }\n   * })\n   * ```\n   */\n  provideModel(model: Record<string, any>): this\n\n  /**\n   * Set the theme for the main Logseq app\n   */\n  provideTheme(theme: Theme): this\n\n  /**\n   * Inject custom css for the main Logseq app\n   *\n   * @example https://github.com/logseq/logseq-plugin-samples/tree/master/logseq-awesome-fonts\n   * @example\n   * ```ts\n   *   logseq.provideStyle(`\n   *    @import url(\"https://at.alicdn.com/t/font_2409735_r7em724douf.css\")",
      "fullDefinition": "export type LSPluginUserEvents = 'ui:visible:changed' | 'settings:changed'\n\nexport interface ILSPluginUser extends EventEmitter<LSPluginUserEvents> {\n  /**\n   * Connection status with the main app\n   */\n  connected: boolean\n\n  /**\n   * Duplex message caller\n   */\n  caller: LSPluginCaller\n\n  /**\n   * The plugin configurations from package.json\n   */\n  baseInfo: LSPluginBaseInfo\n\n  /**\n   * The plugin user settings\n   */\n  settings?: LSPluginBaseInfo['settings']\n\n  /**\n   * The main Logseq app is ready to run the plugin\n   *\n   * @param model - same as the model in `provideModel`\n   */\n  ready(model?: Record<string, any>): Promise<any>\n\n  /**\n   * @param callback - a function to run when the main Logseq app is ready\n   */\n  ready(callback?: (e: any) => void | {}): Promise<any>\n\n  ready(\n    model?: Record<string, any>,\n    callback?: (e: any) => void | {}\n  ): Promise<any>\n\n  beforeunload: (callback: () => Promise<void>) => void\n\n  /**\n   * Create a object to hold the methods referenced in `provideUI`\n   *\n   * @example\n   * ```ts\n   * logseq.provideModel({\n   *  openCalendar () {\n   *    console.log('Open the calendar!')\n   *  }\n   * })\n   * ```\n   */\n  provideModel(model: Record<string, any>): this\n\n  /**\n   * Set the theme for the main Logseq app\n   */\n  provideTheme(theme: Theme): this\n\n  /**\n   * Inject custom css for the main Logseq app\n   *\n   * @example https://github.com/logseq/logseq-plugin-samples/tree/master/logseq-awesome-fonts\n   * @example\n   * ```ts\n   *   logseq.provideStyle(`\n   *    @import url(\"https://at.alicdn.com/t/font_2409735_r7em724douf.css\");",
      "file": "LSPlugin.ts"
    },
    {
      "name": "PluginLocalIdentity",
      "definition": "string\n\nexport type ThemeMode = 'light' | 'dark'\n\nexport interface LegacyTheme {\n  name: string\n  url: string\n  description?: string\n  mode?: ThemeMode\n  pid: PluginLocalIdentity\n}\n\nexport interface Theme extends LegacyTheme {\n  mode: ThemeMode\n}\n\nexport type StyleString = string\nexport type StyleOptions = {\n  key?: string\n  style: StyleString\n}\n\nexport type UIContainerAttrs = {\n  draggable: boolean\n  resizable: boolean\n}\n\nexport type UIBaseOptions = {\n  key?: string\n  replace?: boolean\n  template: string | null\n  style?: CSS.Properties\n  attrs?: Record<string, string>\n  close?: 'outside' | string\n  reset?: boolean // reset slot content or not\n}\n\nexport type UIPathIdentity = {\n  /**\n   * DOM selector\n   */\n  path: string\n}\n\nexport type UISlotIdentity = {\n  /**\n   * Slot key\n   */\n  slot: string\n}\n\nexport type UISlotOptions = UIBaseOptions & UISlotIdentity\n\nexport type UIPathOptions = UIBaseOptions & UIPathIdentity\n\nexport type UIOptions = UIBaseOptions | UIPathOptions | UISlotOptions\n\nexport interface LSPluginPkgConfig {\n  id: PluginLocalIdentity\n  main: string\n  entry: string // alias of main\n  title: string\n  mode: 'shadow' | 'iframe'\n  themes: Theme[]\n  icon: string\n  /**\n   * Alternative entrypoint for development.\n   */\n  devEntry: unknown\n  /**\n   * For legacy themes, do not use.\n   */\n  theme: unknown\n}\n\nexport interface LSPluginBaseInfo {\n  /**\n   * Must be unique.\n   */\n  id: string\n  mode: 'shadow' | 'iframe'\n  settings: {\n    disabled: boolean\n  } & Record<string, unknown>\n  effect: boolean\n  /**\n   * For internal use only. Indicates if plugin is installed in dot root.\n   */\n  iir: boolean\n  /**\n   * For internal use only.\n   */\n  lsr: string\n}\n\nexport type IHookEvent = {\n  [key: string]: any\n}\n\nexport type IUserOffHook = () => void\nexport type IUserHook<E = any, R = IUserOffHook> = (\n  callback: (e: IHookEvent & E) => void\n) => IUserOffHook\nexport type IUserSlotHook<E = any> = (\n  callback: (e: IHookEvent & UISlotIdentity & E) => void\n) => void\nexport type IUserConditionSlotHook<C = any, E = any> = (\n  condition: C,\n  callback: (e: IHookEvent & UISlotIdentity & E) => void\n) => void\n\nexport type EntityID = number\nexport type BlockUUID = string\nexport type BlockUUIDTuple = ['uuid', BlockUUID]\n\nexport type IEntityID = { id: EntityID",
      "fullDefinition": "export type PluginLocalIdentity = string\n\nexport type ThemeMode = 'light' | 'dark'\n\nexport interface LegacyTheme {\n  name: string\n  url: string\n  description?: string\n  mode?: ThemeMode\n  pid: PluginLocalIdentity\n}\n\nexport interface Theme extends LegacyTheme {\n  mode: ThemeMode\n}\n\nexport type StyleString = string\nexport type StyleOptions = {\n  key?: string\n  style: StyleString\n}\n\nexport type UIContainerAttrs = {\n  draggable: boolean\n  resizable: boolean\n}\n\nexport type UIBaseOptions = {\n  key?: string\n  replace?: boolean\n  template: string | null\n  style?: CSS.Properties\n  attrs?: Record<string, string>\n  close?: 'outside' | string\n  reset?: boolean // reset slot content or not\n}\n\nexport type UIPathIdentity = {\n  /**\n   * DOM selector\n   */\n  path: string\n}\n\nexport type UISlotIdentity = {\n  /**\n   * Slot key\n   */\n  slot: string\n}\n\nexport type UISlotOptions = UIBaseOptions & UISlotIdentity\n\nexport type UIPathOptions = UIBaseOptions & UIPathIdentity\n\nexport type UIOptions = UIBaseOptions | UIPathOptions | UISlotOptions\n\nexport interface LSPluginPkgConfig {\n  id: PluginLocalIdentity\n  main: string\n  entry: string // alias of main\n  title: string\n  mode: 'shadow' | 'iframe'\n  themes: Theme[]\n  icon: string\n  /**\n   * Alternative entrypoint for development.\n   */\n  devEntry: unknown\n  /**\n   * For legacy themes, do not use.\n   */\n  theme: unknown\n}\n\nexport interface LSPluginBaseInfo {\n  /**\n   * Must be unique.\n   */\n  id: string\n  mode: 'shadow' | 'iframe'\n  settings: {\n    disabled: boolean\n  } & Record<string, unknown>\n  effect: boolean\n  /**\n   * For internal use only. Indicates if plugin is installed in dot root.\n   */\n  iir: boolean\n  /**\n   * For internal use only.\n   */\n  lsr: string\n}\n\nexport type IHookEvent = {\n  [key: string]: any\n}\n\nexport type IUserOffHook = () => void\nexport type IUserHook<E = any, R = IUserOffHook> = (\n  callback: (e: IHookEvent & E) => void\n) => IUserOffHook\nexport type IUserSlotHook<E = any> = (\n  callback: (e: IHookEvent & UISlotIdentity & E) => void\n) => void\nexport type IUserConditionSlotHook<C = any, E = any> = (\n  condition: C,\n  callback: (e: IHookEvent & UISlotIdentity & E) => void\n) => void\n\nexport type EntityID = number\nexport type BlockUUID = string\nexport type BlockUUIDTuple = ['uuid', BlockUUID]\n\nexport type IEntityID = { id: EntityID;",
      "file": "LSPlugin.ts"
    },
    {
      "name": "PostMateOptions",
      "definition": "{\n  container: HTMLElement\n  url: string\n  id?: string\n  classListArray?: Array<string>\n  name?: string\n  model?: any\n}\n\n/**\n * The entry point of the Parent.\n */\nexport class Postmate {\n  static debug = false // eslint-disable-line no-undef\n  public container?: HTMLElement\n  public parent: Window\n  public frame: HTMLIFrameElement\n  public child?: Window\n  public childOrigin?: string\n  public url: string\n  public model: any\n  static Model: any\n\n  /**\n   * @param opts\n   */\n  constructor(opts: PostMateOptions) {\n    this.container = opts.container\n    this.url = opts.url\n    this.parent = window\n    this.frame = document.createElement('iframe')\n    if (opts.id) this.frame.id = opts.id\n    if (opts.name) this.frame.name = opts.name\n    this.frame.classList.add.apply(\n      this.frame.classList,\n      opts.classListArray || []\n    )\n    this.container.appendChild(this.frame)\n    this.child = this.frame.contentWindow\n    this.model = opts.model || {}\n  }\n\n  /**\n   * Begins the handshake strategy\n   * @param  {String} url The URL to send a handshake request to\n   * @return {Promise}     Promise that resolves when the handshake is complete\n   */\n  sendHandshake(url?: string) {\n    url = url || this.url\n    const childOrigin = resolveOrigin(url)\n    let attempt = 0\n    let responseInterval\n    return new Promise((resolve, reject) => {\n      const reply = (e: any) => {\n        if (!sanitize(e, childOrigin)) return false\n        if (e.data.postmate === 'handshake-reply') {\n          clearInterval(responseInterval)\n          if (process.env.NODE_ENV !== 'production') {\n            log('Parent: Received handshake reply from Child')\n          }\n          this.parent.removeEventListener('message', reply, false)\n          this.childOrigin = e.origin\n          if (process.env.NODE_ENV !== 'production') {\n            log('Parent: Saving Child origin', this.childOrigin)\n          }\n          return resolve(new ParentAPI(this))\n        }\n\n        // Might need to remove since parent might be receiving different messages\n        // from different hosts\n        if (process.env.NODE_ENV !== 'production') {\n          log('Parent: Invalid handshake reply')\n        }\n        return reject('Failed handshake')\n      }\n\n      this.parent.addEventListener('message', reply, false)\n\n      const doSend = () => {\n        attempt++\n        if (process.env.NODE_ENV !== 'production') {\n          log(`Parent: Sending handshake attempt ${attempt}`, { childOrigin })\n        }\n        this.child.postMessage(\n          {\n            postmate: 'handshake',\n            type: messageType,\n            model: this.model,\n          },\n          childOrigin\n        )\n\n        if (attempt === maxHandshakeRequests) {\n          clearInterval(responseInterval)\n        }\n      }\n\n      const loaded = () => {\n        doSend()\n        responseInterval = setInterval(doSend, 500)\n      }\n\n      this.frame.addEventListener('load', loaded)\n\n      if (process.env.NODE_ENV !== 'production') {\n        log('Parent: Loading frame', { url })\n      }\n      this.frame.src = url\n    })\n  }\n\n  destroy() {\n    if (process.env.NODE_ENV !== 'production') {\n      log('Postmate: Destroying Postmate instance')\n    }\n    this.frame.parentNode.removeChild(this.frame)\n  }\n}\n\n/**\n * The entry point of the Child\n */\nexport class Model {\n  public child: Window\n  public model: any\n  public parent: Window\n  public parentOrigin: string\n\n  /**\n   * Initializes the child, model, parent, and responds to the Parents handshake\n   * @param {Object} model Hash of values, functions, or promises\n   * @return {Promise}       The Promise that resolves when the handshake has been received\n   */\n  constructor(model) {\n    this.child = window\n    this.model = model\n    this.parent = this.child.parent\n  }\n\n  /**\n   * Responds to a handshake initiated by the Parent\n   * @return {Promise} Resolves an object that exposes an API for the Child\n   */\n  sendHandshakeReply() {\n    return new Promise((resolve, reject) => {\n      const shake = (e: MessageEvent<any>) => {\n        if (!e.data.postmate) {\n          return\n        }\n        if (e.data.postmate === 'handshake') {\n          if (process.env.NODE_ENV !== 'production') {\n            log('Child: Received handshake from Parent')\n          }\n          this.child.removeEventListener('message', shake, false)\n          if (process.env.NODE_ENV !== 'production') {\n            log('Child: Sending handshake reply to Parent')\n          }",
      "fullDefinition": "export type PostMateOptions = {\n  container: HTMLElement\n  url: string\n  id?: string\n  classListArray?: Array<string>\n  name?: string\n  model?: any\n}\n\n/**\n * The entry point of the Parent.\n */\nexport class Postmate {\n  static debug = false // eslint-disable-line no-undef\n  public container?: HTMLElement\n  public parent: Window\n  public frame: HTMLIFrameElement\n  public child?: Window\n  public childOrigin?: string\n  public url: string\n  public model: any\n  static Model: any\n\n  /**\n   * @param opts\n   */\n  constructor(opts: PostMateOptions) {\n    this.container = opts.container\n    this.url = opts.url\n    this.parent = window\n    this.frame = document.createElement('iframe')\n    if (opts.id) this.frame.id = opts.id\n    if (opts.name) this.frame.name = opts.name\n    this.frame.classList.add.apply(\n      this.frame.classList,\n      opts.classListArray || []\n    )\n    this.container.appendChild(this.frame)\n    this.child = this.frame.contentWindow\n    this.model = opts.model || {}\n  }\n\n  /**\n   * Begins the handshake strategy\n   * @param  {String} url The URL to send a handshake request to\n   * @return {Promise}     Promise that resolves when the handshake is complete\n   */\n  sendHandshake(url?: string) {\n    url = url || this.url\n    const childOrigin = resolveOrigin(url)\n    let attempt = 0\n    let responseInterval\n    return new Promise((resolve, reject) => {\n      const reply = (e: any) => {\n        if (!sanitize(e, childOrigin)) return false\n        if (e.data.postmate === 'handshake-reply') {\n          clearInterval(responseInterval)\n          if (process.env.NODE_ENV !== 'production') {\n            log('Parent: Received handshake reply from Child')\n          }\n          this.parent.removeEventListener('message', reply, false)\n          this.childOrigin = e.origin\n          if (process.env.NODE_ENV !== 'production') {\n            log('Parent: Saving Child origin', this.childOrigin)\n          }\n          return resolve(new ParentAPI(this))\n        }\n\n        // Might need to remove since parent might be receiving different messages\n        // from different hosts\n        if (process.env.NODE_ENV !== 'production') {\n          log('Parent: Invalid handshake reply')\n        }\n        return reject('Failed handshake')\n      }\n\n      this.parent.addEventListener('message', reply, false)\n\n      const doSend = () => {\n        attempt++\n        if (process.env.NODE_ENV !== 'production') {\n          log(`Parent: Sending handshake attempt ${attempt}`, { childOrigin })\n        }\n        this.child.postMessage(\n          {\n            postmate: 'handshake',\n            type: messageType,\n            model: this.model,\n          },\n          childOrigin\n        )\n\n        if (attempt === maxHandshakeRequests) {\n          clearInterval(responseInterval)\n        }\n      }\n\n      const loaded = () => {\n        doSend()\n        responseInterval = setInterval(doSend, 500)\n      }\n\n      this.frame.addEventListener('load', loaded)\n\n      if (process.env.NODE_ENV !== 'production') {\n        log('Parent: Loading frame', { url })\n      }\n      this.frame.src = url\n    })\n  }\n\n  destroy() {\n    if (process.env.NODE_ENV !== 'production') {\n      log('Postmate: Destroying Postmate instance')\n    }\n    this.frame.parentNode.removeChild(this.frame)\n  }\n}\n\n/**\n * The entry point of the Child\n */\nexport class Model {\n  public child: Window\n  public model: any\n  public parent: Window\n  public parentOrigin: string\n\n  /**\n   * Initializes the child, model, parent, and responds to the Parents handshake\n   * @param {Object} model Hash of values, functions, or promises\n   * @return {Promise}       The Promise that resolves when the handshake has been received\n   */\n  constructor(model) {\n    this.child = window\n    this.model = model\n    this.parent = this.child.parent\n  }\n\n  /**\n   * Responds to a handshake initiated by the Parent\n   * @return {Promise} Resolves an object that exposes an API for the Child\n   */\n  sendHandshakeReply() {\n    return new Promise((resolve, reject) => {\n      const shake = (e: MessageEvent<any>) => {\n        if (!e.data.postmate) {\n          return\n        }\n        if (e.data.postmate === 'handshake') {\n          if (process.env.NODE_ENV !== 'production') {\n            log('Child: Received handshake from Parent')\n          }\n          this.child.removeEventListener('message', shake, false)\n          if (process.env.NODE_ENV !== 'production') {\n            log('Child: Sending handshake reply to Parent')\n          }\n          ;",
      "file": "postmate/index.ts"
    },
    {
      "name": "UIMsgOptions",
      "definition": "{\n  key: string\n  timeout: number // milliseconds. `0` indicate that keep showing\n}\n\nexport type UIMsgKey = UIMsgOptions['key']\n\nexport interface IUIProxy {\n  showMsg: (\n    content: string,\n    status?: 'success' | 'warning' | 'error' | string,\n    opts?: Partial<UIMsgOptions>\n  ) => Promise<UIMsgKey>\n  closeMsg: (key: UIMsgKey) => void\n  queryElementRect: (selector: string) => Promise<DOMRectReadOnly | null>\n  queryElementById: (id: string) => Promise<string | boolean>\n  checkSlotValid: (slot: UISlotIdentity['slot']) => Promise<boolean>\n  resolveThemeCssPropsVals: (props: string | Array<string>) => Promise<Record<string, string | undefined> | null>\n}\n\nexport interface IUtilsProxy {\n  toJs: <R = unknown>(obj: {}) => Promise<R>\n}\n\n/**\n * Assets related APIs\n */\nexport interface IAssetsProxy {\n  /**\n   * @added 0.0.2\n   * @param exts\n   */\n  listFilesOfCurrentGraph(exts?: string | string[]): Promise<\n    Array<{\n      path: string\n      size: number\n      accessTime: number\n      modifiedTime: number\n      changeTime: number\n      birthTime: number\n    }>\n  >\n\n  /**\n   * @example https://github.com/logseq/logseq/pull/6488\n   * @added 0.0.10\n   */\n  makeSandboxStorage(): IAsyncStorage\n\n  /**\n   * make assets scheme url based on current graph\n   * @added 0.0.15\n   * @param path\n   */\n  makeUrl(path: string): Promise<string>\n\n  /**\n   * try to open asset type file in Logseq app\n   * @added 0.0.16\n   * @param path\n   */\n  builtInOpen(path: string): Promise<boolean | undefined>\n}\n\nexport interface ILSPluginThemeManager {\n  get themes(): Map<PluginLocalIdentity, Theme[]>\n\n  registerTheme(id: PluginLocalIdentity, opt: Theme): Promise<void>\n\n  unregisterTheme(id: PluginLocalIdentity, effect?: boolean): Promise<void>\n\n  selectTheme(\n    opt: Theme | LegacyTheme,\n    options: { effect?: boolean",
      "fullDefinition": "export type UIMsgOptions = {\n  key: string\n  timeout: number // milliseconds. `0` indicate that keep showing\n}\n\nexport type UIMsgKey = UIMsgOptions['key']\n\nexport interface IUIProxy {\n  showMsg: (\n    content: string,\n    status?: 'success' | 'warning' | 'error' | string,\n    opts?: Partial<UIMsgOptions>\n  ) => Promise<UIMsgKey>\n  closeMsg: (key: UIMsgKey) => void\n  queryElementRect: (selector: string) => Promise<DOMRectReadOnly | null>\n  queryElementById: (id: string) => Promise<string | boolean>\n  checkSlotValid: (slot: UISlotIdentity['slot']) => Promise<boolean>\n  resolveThemeCssPropsVals: (props: string | Array<string>) => Promise<Record<string, string | undefined> | null>\n}\n\nexport interface IUtilsProxy {\n  toJs: <R = unknown>(obj: {}) => Promise<R>\n}\n\n/**\n * Assets related APIs\n */\nexport interface IAssetsProxy {\n  /**\n   * @added 0.0.2\n   * @param exts\n   */\n  listFilesOfCurrentGraph(exts?: string | string[]): Promise<\n    Array<{\n      path: string\n      size: number\n      accessTime: number\n      modifiedTime: number\n      changeTime: number\n      birthTime: number\n    }>\n  >\n\n  /**\n   * @example https://github.com/logseq/logseq/pull/6488\n   * @added 0.0.10\n   */\n  makeSandboxStorage(): IAsyncStorage\n\n  /**\n   * make assets scheme url based on current graph\n   * @added 0.0.15\n   * @param path\n   */\n  makeUrl(path: string): Promise<string>\n\n  /**\n   * try to open asset type file in Logseq app\n   * @added 0.0.16\n   * @param path\n   */\n  builtInOpen(path: string): Promise<boolean | undefined>\n}\n\nexport interface ILSPluginThemeManager {\n  get themes(): Map<PluginLocalIdentity, Theme[]>\n\n  registerTheme(id: PluginLocalIdentity, opt: Theme): Promise<void>\n\n  unregisterTheme(id: PluginLocalIdentity, effect?: boolean): Promise<void>\n\n  selectTheme(\n    opt: Theme | LegacyTheme,\n    options: { effect?: boolean;",
      "file": "LSPlugin.ts"
    }
  ],
  "enums": [],
  "classes": [
    {
      "name": "ChildAPI",
      "file": "postmate/index.ts"
    },
    {
      "name": "LSPluginExperiments",
      "file": "modules/LSPlugin.Experiments.ts"
    },
    {
      "name": "LSPluginRequest",
      "file": "modules/LSPlugin.Request.ts"
    },
    {
      "name": "LSPluginSearchService",
      "file": "modules/LSPlugin.Search.ts"
    },
    {
      "name": "LSPluginUser",
      "file": "LSPlugin.user.ts"
    },
    {
      "name": "Model",
      "file": "postmate/index.ts"
    },
    {
      "name": "ParentAPI",
      "file": "postmate/index.ts"
    },
    {
      "name": "PluginLogger",
      "file": "helpers.ts"
    },
    {
      "name": "Postmate",
      "file": "postmate/index.ts"
    }
  ]
}